<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SectionAnalysis</title>
  <meta name="keywords" content="SectionAnalysis">
  <meta name="description" content="______________________________________________________________________">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # mcurv --><!-- menu.html section -->
<h1>SectionAnalysis
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>______________________________________________________________________</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ______________________________________________________________________
|                                                                      |
|           MCURV - Toolbox para Calculo de Momento Curvatura          |
|                                                                      |
|                    Area de Estructuras y Geotecnia                   |
|                   Departamento de Ingenieria Civil                   |
|              Facultad de Ciencias Fisicas y Matematicas              |
|                         Universidad de Chile                         |
|                                                                      |
| MCURV es una plataforma en MATLAB que permite realizar calculos de   |
| momento curvatura de secciones genericas utilizando la metodologia de|
| calculo no lineal Newton-Raphson.                                    |
|______________________________________________________________________|
|                                                                      |
| SectionAnalysis                                                      |
|                                                                      |
| Analiza una seccion, permitiendo calcular diagrama momento curvatura |
| de cualquier seccion tipo SectionDesigner.                           |
|                                                                      |
| Autor: Pablo Pizarro R. @ppizarror.com                               |
| Licencia: MIT                                                        |
| Codigo fuente: https://github.com/ppizarror/MCURV                    |
|______________________________________________________________________|</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>	______________________________________________________________________</li><li><a href="SectionAnalysis.html" class="code" title="">SectionAnalysis</a>	______________________________________________________________________</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="SectionAnalysis.html" class="code" title="">SectionAnalysis</a>	______________________________________________________________________</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = SectionAnalysis(analysisName, maxiter, tol)</a></li><li><a href="#_sub2" class="code">function [mxInt, myInt, pInt, pE0, jacIter, deltaE0Iter,</a></li><li><a href="#_sub3" class="code">function plot_e0M(obj, varargin)</a></li><li><a href="#_sub4" class="code">function disp(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ______________________________________________________________________</span>
0002 <span class="comment">%|                                                                      |</span>
0003 <span class="comment">%|           MCURV - Toolbox para Calculo de Momento Curvatura          |</span>
0004 <span class="comment">%|                                                                      |</span>
0005 <span class="comment">%|                    Area de Estructuras y Geotecnia                   |</span>
0006 <span class="comment">%|                   Departamento de Ingenieria Civil                   |</span>
0007 <span class="comment">%|              Facultad de Ciencias Fisicas y Matematicas              |</span>
0008 <span class="comment">%|                         Universidad de Chile                         |</span>
0009 <span class="comment">%|                                                                      |</span>
0010 <span class="comment">%| MCURV es una plataforma en MATLAB que permite realizar calculos de   |</span>
0011 <span class="comment">%| momento curvatura de secciones genericas utilizando la metodologia de|</span>
0012 <span class="comment">%| calculo no lineal Newton-Raphson.                                    |</span>
0013 <span class="comment">%|______________________________________________________________________|</span>
0014 <span class="comment">%|                                                                      |</span>
0015 <span class="comment">%| SectionAnalysis                                                      |</span>
0016 <span class="comment">%|                                                                      |</span>
0017 <span class="comment">%| Analiza una seccion, permitiendo calcular diagrama momento curvatura |</span>
0018 <span class="comment">%| de cualquier seccion tipo SectionDesigner.                           |</span>
0019 <span class="comment">%|                                                                      |</span>
0020 <span class="comment">%| Autor: Pablo Pizarro R. @ppizarror.com                               |</span>
0021 <span class="comment">%| Licencia: MIT                                                        |</span>
0022 <span class="comment">%| Codigo fuente: https://github.com/ppizarror/MCURV                    |</span>
0023 <span class="comment">%|______________________________________________________________________|</span>
0024 
0025 classdef <a href="SectionAnalysis.html" class="code" title="">SectionAnalysis</a> &lt; <a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>
0026     
0027     properties(Access = protected)
0028         maxiter <span class="comment">% Numero maximo de iteraciones</span>
0029         tol <span class="comment">% Tolerancia del calculo</span>
0030         lastsole0p <span class="comment">% Ultima solucion de e0/P</span>
0031     <span class="keyword">end</span> <span class="comment">% protected properties</span>
0032     
0033     methods(Access = public)
0034         
0035         <a name="_sub0" href="#_subfunctions" class="code">function obj = SectionAnalysis(analysisName, maxiter, tol)</a>
0036             <span class="comment">% SectionAnalysis: Constructor de la clase</span>
0037             
0038             obj = obj@<a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>(analysisName);
0039             obj.maxiter = maxiter;
0040             obj.tol = tol;
0041             obj.lastsole0p = {};
0042             
0043         <span class="keyword">end</span> <span class="comment">% SectionAnalysis constructor</span>
0044         
0045         <a name="_sub1" href="#_subfunctions" class="code">function [mxInt, myInt, pInt, pE0, jacIter, deltaE0Iter, </a><span class="keyword">...</span>
0046                 err, defTotal, problmIter, iters] = calc_e0M(obj, section, p, phix, phiy)
0047             <span class="comment">% calc_e0M: Calcula e0 y M dado un arreglo de cargas y</span>
0048             <span class="comment">% curvaturas</span>
0049             
0050             fprintf(<span class="string">'Calculando e0 y M dado arreglo de P y phix,phiy\n'</span>);
0051             fprintf(<span class="string">'\tSeccion: %s\n'</span>, section.getName());
0052             
0053             <span class="comment">% Actualiza propiedades</span>
0054             section.updateProps();
0055             
0056             <span class="comment">% Genera el vector de cambio de P</span>
0057             n = length(p);
0058             delta_p = zeros(n, 1);
0059             delta_p(1) = p(1);
0060             <span class="keyword">for</span> i = 2:n
0061                 delta_p(i) = p(i) - p(i-1);
0062             <span class="keyword">end</span>
0063             
0064             <span class="comment">% Crea matriz de iteraciones de la deformacion total</span>
0065             deltaE0Iter = zeros(n, obj.maxiter);
0066             pE0 = zeros(n, obj.maxiter);
0067             jacIter = zeros(n, obj.maxiter); <span class="comment">% Jacobiano (rigidez)</span>
0068             
0069             defTotal = zeros(n, 1); <span class="comment">% Deformacion total para cada [P,phi]_i</span>
0070             err = zeros(n, obj.maxiter); <span class="comment">% Error de cada iteracion</span>
0071             
0072             iters = zeros(n, 1); <span class="comment">% Numero de iteraciones necesitados</span>
0073             problmIter = zeros(n, 1); <span class="comment">% Indica que iteracion tuvo problemas</span>
0074             
0075             <span class="comment">% Cargas internas guardadas</span>
0076             pInt = zeros(n, 1); <span class="comment">% Carga efectiva de cada (P,phi)</span>
0077             mxInt = zeros(n, 1); <span class="comment">% Momento por cada (P,phi)</span>
0078             myInt = zeros(n, 1); <span class="comment">% Momento por cada (P,phi)</span>
0079             reverse_porcent = <span class="string">''</span>; <span class="comment">% Texto que tiene el porcentaje de avance</span>
0080             
0081             <span class="comment">% Variable que indica que las iteraciones se hacen con la primera</span>
0082             <span class="comment">% pendiente de la matriz de rigidez</span>
0083             usar1JAC = false;
0084             
0085             <span class="comment">% Almacena desde que i-incremento se usa el primer jacobiano</span>
0086             usar1JACNITER = 1;
0087             
0088             <span class="comment">% Aplicacion de carga</span>
0089             <span class="keyword">for</span> i = 1:n
0090                 
0091                 <span class="comment">% Iteracion con variacion del jacobiano</span>
0092                 <span class="keyword">if</span> ~usar1JAC
0093                     
0094                     <span class="comment">% Calcula el primer delta_eo, considera deformacion total como la suma</span>
0095                     <span class="comment">% de los delta_e0 de cada iteracion</span>
0096                     jac = section.calcJac(defTotal(i), phix(i), phiy(i));
0097                     jac = jac(1, 1); <span class="comment">% Solo escata aP/ae0</span>
0098                     jac = jac^-1;
0099                     jacIter(i, 1) = jac(1, 1);
0100                     deltaE0Iter(i, 1) = jacIter(i, 1) * delta_p(i);
0101                     
0102                     <span class="keyword">for</span> j = 1:(obj.maxiter - 1)
0103                         
0104                         <span class="comment">% Incrementa iteracion</span>
0105                         iters(i) = iters(i) + 1;
0106                         
0107                         <span class="comment">% Actualiza deformacion total</span>
0108                         <span class="keyword">if</span> i &gt; 1
0109                             defTotal(i) = defTotal(i-1) + sum(deltaE0Iter(i, :));
0110                         <span class="keyword">else</span>
0111                             defTotal(i) = sum(deltaE0Iter(i, :));
0112                         <span class="keyword">end</span>
0113                         
0114                         <span class="comment">% Calcula la fuerza interna</span>
0115                         pE0(i, j) = section.calcP(defTotal(i), phix(i), phiy(i));
0116                         
0117                         <span class="comment">% Calcula el error entre carga aproximada y exacta</span>
0118                         err(i, j) = p(i) - pE0(i, j);
0119                         <span class="keyword">if</span> abs(err(i, j)) &lt; obj.tol &amp;&amp; (i &gt; 1 &amp;&amp; pE0(i, j) ~= 0) || (i == 1 &amp;&amp; pE0(i, j) == 0)
0120                             <span class="keyword">break</span>;
0121                         <span class="keyword">end</span>
0122                         
0123                         <span class="comment">% Si es mayor a la tolerancia</span>
0124                         jac = section.calcJac(sum(deltaE0Iter(i, :)), phix(i), phiy(i));
0125                         jac = jac(1, 1); <span class="comment">% Solo escata aP/ae0</span>
0126                         jac = jac^-1;
0127                         jacIter(i, j+1) = jac(1, 1);
0128                         deltaE0Iter(i, j+1) = jacIter(i, j+1) * err(i, j);
0129                         
0130                         <span class="comment">% Si se pasa del error detiene y usa la pendiente del primer</span>
0131                         <span class="comment">% intervalo</span>
0132                         <span class="keyword">if</span> j &gt; 1 &amp;&amp; (abs(deltaE0Iter(i, j+1)) &gt; abs(deltaE0Iter(i, j))) || (pE0(i, j) == 0 &amp;&amp; i &gt; 1)
0133                             <span class="keyword">for</span> jj = 1:j + 1
0134                                 deltaE0Iter(i, jj) = 0;
0135                             <span class="keyword">end</span>
0136                             usar1JAC = true;
0137                             jacIter(i, 1) = jacIter(1, 1);
0138                             usar1JACNITER = i;
0139                             <span class="keyword">break</span>;
0140                         <span class="keyword">end</span>
0141                         
0142                     <span class="keyword">end</span>
0143                     
0144                 <span class="keyword">else</span> <span class="comment">% Itera con la primera pendiente</span>
0145                     
0146                     <span class="comment">% Asigna el primer jacobiano</span>
0147                     jacIter(i, 1) = jacIter(1, 1);
0148                     
0149                     <span class="keyword">for</span> j = 1:(obj.maxiter - 1)
0150                         
0151                         <span class="comment">% Incrementa iteracion</span>
0152                         iters(i) = iters(i) + 1;
0153                         
0154                         <span class="comment">% Actualiza deformacion total</span>
0155                         <span class="keyword">if</span> i &gt; 1
0156                             defTotal(i) = defTotal(i-1) + sum(deltaE0Iter(i, :));
0157                         <span class="keyword">else</span>
0158                             defTotal(i) = sum(deltaE0Iter(i, :));
0159                         <span class="keyword">end</span>
0160                         
0161                         <span class="comment">% Calcula la fuerza interna [N]</span>
0162                         pE0(i, j) = section.calcP(defTotal(i), phix(i), phiy(i));
0163                         
0164                         <span class="comment">% Calcula el error entre carga aproximada y exacta</span>
0165                         err(i, j) = p(i) - pE0(i, j);
0166                         <span class="keyword">if</span> abs(err(i, j)) &lt; obj.tol
0167                             <span class="keyword">break</span>;
0168                         <span class="keyword">end</span>
0169                         
0170                         <span class="comment">% Si es mayor a la tolerancia</span>
0171                         jacIter(i, j+1) = jacIter(i, j); <span class="comment">% Puede ser jac_iter(i, 1)</span>
0172                         deltaE0Iter(i, j+1) = jacIter(i, j+1) * err(i, j);
0173                         
0174                         <span class="comment">% Si se pasa del error detiene y usa el j anterior</span>
0175                         <span class="keyword">if</span> j &gt; 1 &amp;&amp; (abs(deltaE0Iter(i, j+1)) &gt; abs(deltaE0Iter(i, j)))
0176                             jacIter(i, j) = 0.5 * jacIter(i, j-1);
0177                             j = j - 1; <span class="comment">%#ok&lt;FXSET&gt;</span>
0178                         <span class="keyword">end</span>
0179                         
0180                     <span class="keyword">end</span>
0181                     
0182                 <span class="keyword">end</span>
0183                 
0184                 <span class="comment">% Actualiza deformacion total</span>
0185                 <span class="keyword">if</span> i &gt; 1
0186                     defTotal(i) = defTotal(i-1) + sum(deltaE0Iter(i, :));
0187                 <span class="keyword">else</span>
0188                     defTotal(i) = sum(deltaE0Iter(i, :));
0189                 <span class="keyword">end</span>
0190                 
0191                 <span class="comment">% Guarda el P calculado</span>
0192                 pInt(i) = pE0(i, j);
0193                 
0194                 <span class="comment">% Calcula el momento</span>
0195                 mxInt(i) = section.calcMx(defTotal(i), phix(i), phiy(i));
0196                 myInt(i) = section.calcMy(defTotal(i), phix(i), phiy(i));
0197                 
0198                 <span class="comment">% Escribe el porcentaje</span>
0199                 msg = sprintf(<span class="string">'\tCalculando... (%.1f/100)'</span>, i/n*100);
0200                 fprintf([reverse_porcent, msg]);
0201                 reverse_porcent = repmat(sprintf(<span class="string">'\b'</span>), 1, length(msg));
0202                 
0203             <span class="keyword">end</span>
0204             
0205             <span class="comment">% Imprime resultados</span>
0206             fprintf(<span class="string">'\n'</span>);
0207             fprintf(<span class="string">'\tIteraciones totales: %d\n'</span>, sum(iters));
0208             fprintf(<span class="string">'\tUsado primera matriz rigidez desde i: %d\n'</span>, usar1JACNITER);
0209             
0210             <span class="comment">% Guarda la solucion</span>
0211             obj.lastsole0p = {mxInt, myInt, phix, phiy, pInt, p, pE0};
0212             
0213         <span class="keyword">end</span> <span class="comment">% calc_e0M function</span>
0214         
0215         <a name="_sub2" href="#_subfunctions" class="code">function plot_e0M(obj, varargin)</a>
0216             <span class="comment">% plot_e0M: Grafica el ultimo analisis de e0M</span>
0217             <span class="comment">%</span>
0218             <span class="comment">% Parametros opcionales:</span>
0219             <span class="comment">%   factor          Factor de escala para el momento</span>
0220             <span class="comment">%   medfilt         Aplica medfilt</span>
0221             <span class="comment">%   medfiltN        Numero de filtro</span>
0222             <span class="comment">%   limPos          Limita analisis a valores positivos</span>
0223             <span class="comment">%   plot            Tipo de grafico</span>
0224             <span class="comment">%   unitlength      Unidad de longitud</span>
0225             <span class="comment">%   legend          Ubicacion de la leyenda</span>
0226             <span class="comment">%   unitload        Unidad de carga</span>
0227             
0228             p = inputParser;
0229             p.KeepUnmatched = true;
0230             p.addOptional(<span class="string">'factor'</span>, 1); <span class="comment">% Si se usan N*mm a tonf-m</span>
0231             p.addOptional(<span class="string">'limPos'</span>, true)
0232             p.addOptional(<span class="string">'medfilt'</span>, true); <span class="comment">% Aplica medfilt</span>
0233             p.addOptional(<span class="string">'medfiltN'</span>, 3);
0234             p.addOptional(<span class="string">'plot'</span>, <span class="string">'all'</span>);
0235             p.addOptional(<span class="string">'legend'</span>, <span class="string">'southeast'</span>);
0236             p.addOptional(<span class="string">'unitlength'</span>, <span class="string">'1/mm'</span>); <span class="comment">% Unidad de largo</span>
0237             p.addOptional(<span class="string">'unitload'</span>, <span class="string">'kN*m'</span>); <span class="comment">% Unidad de carga</span>
0238             parse(p, varargin{:});
0239             r = p.Results;
0240             
0241             <span class="keyword">if</span> isempty(obj.lastsole0p)
0242                 error(<span class="string">'Analisis e0M no ha sido ejecutado'</span>);
0243             <span class="keyword">end</span>
0244             
0245             mxInt = obj.lastsole0p{1} .* r.factor;
0246             myInt = obj.lastsole0p{2} .* r.factor;
0247             pInt = obj.lastsole0p{5};
0248             <span class="comment">% pRre = obj.lastsole0p{6};</span>
0249             phix = obj.lastsole0p{3};
0250             phiy = obj.lastsole0p{4};
0251             <span class="comment">% e0 = obj.lastsole0p{7};</span>
0252             
0253             <span class="comment">% Aplica medfilt</span>
0254             <span class="keyword">if</span> r.medfilt
0255                 mxInt = medfilt1(mxInt, r.medfiltN);
0256                 myInt = medfilt1(myInt, r.medfiltN);
0257             <span class="keyword">end</span>
0258             
0259             <span class="keyword">if</span> strcmp(r.plot, <span class="string">'all'</span>) || strcmp(r.plot, <span class="string">'mphiy'</span>)
0260                 plt = figure();
0261                 movegui(plt, <span class="string">'center'</span>);
0262                 set(gcf, <span class="string">'name'</span>, <span class="string">'Momento curvatura'</span>);
0263                 plot(phiy, mxInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0264                 hold on;
0265                 plot(phiy, myInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0266                 grid on;
0267                 grid minor;
0268                 xlabel(sprintf(<span class="string">'Curvatura \\phi_y (%s)'</span>, r.unitlength));
0269                 ylabel(sprintf(<span class="string">'Momento M (%s)'</span>, r.unitload));
0270                 title(<span class="string">'Momento curvatura M/\phi_y'</span>);
0271                 legend({<span class="string">'M_x'</span>, <span class="string">'M_y'</span>}, <span class="string">'location'</span>, r.legend);
0272                 <span class="keyword">if</span> r.limPos
0273                     ylim([0, max(get(gca, <span class="string">'ylim'</span>))]);
0274                 <span class="keyword">end</span>
0275             <span class="keyword">end</span>
0276             
0277             <span class="keyword">if</span> strcmp(r.plot, <span class="string">'all'</span>) || strcmp(r.plot, <span class="string">'mphix'</span>)
0278                 plt = figure();
0279                 movegui(plt, <span class="string">'center'</span>);
0280                 set(gcf, <span class="string">'name'</span>, <span class="string">'Momento curvatura'</span>);
0281                 plot(phix, mxInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0282                 hold on;
0283                 plot(phix, myInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0284                 grid on;
0285                 grid minor;
0286                 xlabel(sprintf(<span class="string">'Curvatura \\phi_x (%s)'</span>, r.unitlength));
0287                 ylabel(sprintf(<span class="string">'Momento M (%s)'</span>, r.unitload));
0288                 title(<span class="string">'Momento curvatura M/\phi_x'</span>);
0289                 legend({<span class="string">'M_x'</span>, <span class="string">'M_y'</span>}, <span class="string">'location'</span>, r.legend);
0290                 <span class="keyword">if</span> r.limPos
0291                     ylim([0, max(get(gca, <span class="string">'ylim'</span>))]);
0292                 <span class="keyword">end</span>
0293             <span class="keyword">end</span>
0294             
0295             <span class="keyword">if</span> strcmp(r.plot, <span class="string">'all'</span>) || strcmp(r.plot, <span class="string">'pphix'</span>)
0296                 plt = figure();
0297                 movegui(plt, <span class="string">'center'</span>);
0298                 set(gcf, <span class="string">'name'</span>, <span class="string">'P vs \phi_x'</span>);
0299                 plot(phix, pInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0300                 grid on;
0301                 grid minor;
0302                 xlabel(sprintf(<span class="string">'Curvatura \\phi_x (%s)'</span>, r.unitload));
0303                 ylabel(<span class="string">'Carga axial P'</span>);
0304                 title(<span class="string">'Carga axial vs curvatura'</span>);
0305                 <span class="keyword">if</span> r.limPos
0306                     ylim([0, max(get(gca, <span class="string">'ylim'</span>))]);
0307                 <span class="keyword">end</span>
0308             <span class="keyword">end</span>
0309             
0310             <span class="keyword">if</span> strcmp(r.plot, <span class="string">'all'</span>) || strcmp(r.plot, <span class="string">'pphiy'</span>)
0311                 plt = figure();
0312                 movegui(plt, <span class="string">'center'</span>);
0313                 set(gcf, <span class="string">'name'</span>, <span class="string">'P vs \phi_y'</span>);
0314                 plot(phiy, pInt, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1.5);
0315                 grid on;
0316                 grid minor;
0317                 xlabel(sprintf(<span class="string">'Curvatura \\phi_y (%s)'</span>, r.unitload));
0318                 ylabel(<span class="string">'Carga axial P'</span>);
0319                 title(<span class="string">'Carga axial vs curvatura'</span>);
0320                 <span class="keyword">if</span> r.limPos
0321                     ylim([0, max(get(gca, <span class="string">'ylim'</span>))]);
0322                 <span class="keyword">end</span>
0323             <span class="keyword">end</span>
0324             
0325             <span class="comment">% Finaliza el grafico</span>
0326             drawnow();
0327             
0328         <span class="keyword">end</span> <span class="comment">% plote0M function</span>
0329         
0330         <a name="_sub3" href="#_subfunctions" class="code">function disp(obj)</a>
0331             <span class="comment">% disp: Imprime la informacion del objeto en consola</span>
0332             
0333             fprintf(<span class="string">'Analisis de seccion:\n'</span>);
0334             <a href="#_sub4" class="code" title="subfunction disp(obj)">disp</a>@<a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>(obj);
0335             
0336         <span class="keyword">end</span> <span class="comment">% disp function</span>
0337         
0338     <span class="keyword">end</span> <span class="comment">% public methods</span>
0339     
0340 <span class="keyword">end</span> <span class="comment">% SectionAnalysis class</span></pre></div>
<hr><address>Generated on Thu 16-May-2019 02:09:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>