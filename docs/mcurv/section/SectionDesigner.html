<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SectionDesigner</title>
  <meta name="keywords" content="SectionDesigner">
  <meta name="description" content="______________________________________________________________________">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # mcurv --><!-- menu.html section -->
<h1>SectionDesigner
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>______________________________________________________________________</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ______________________________________________________________________
|                                                                      |
|           MCURV - Toolbox para Calculo de Momento Curvatura          |
|                                                                      |
|                    Area de Estructuras y Geotecnia                   |
|                   Departamento de Ingenieria Civil                   |
|              Facultad de Ciencias Fisicas y Matematicas              |
|                         Universidad de Chile                         |
|                                                                      |
| MCURV es una plataforma en MATLAB que permite realizar calculos de   |
| momento curvatura de secciones genericas utilizando la metodologia de|
| calculo no lineal Newton-Raphson.                                    |
|______________________________________________________________________|
|                                                                      |
| SectionDesigner                                                      |
|                                                                      |
| Clase que define la geometria y materialidad de una seccion prima-   |
| tica.                                                                |
|                                                                      |
| Autor: Pablo Pizarro R. @ppizarror.com                               |
| Licencia: MIT                                                        |
| Codigo fuente: https://github.com/ppizarror/MCURV                    |
|______________________________________________________________________|</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>	______________________________________________________________________</li><li><a href="SectionDesigner.html" class="code" title="">SectionDesigner</a>	______________________________________________________________________</li><li><a href="../../mcurv/utils/dispMCURV.html" class="code" title="function dispMCURV()">dispMCURV</a>	dispMCURV: Normaliza la salida estandar disp en consola de los</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="SectionDesigner.html" class="code" title="">SectionDesigner</a>	______________________________________________________________________</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = SectionDesigner(matName)</a></li><li><a href="#_sub2" class="code">function addDiscreteRect(obj, xc, yc, b, h, nx, ny, material, varargin)</a></li><li><a href="#_sub3" class="code">function addFiniteArea(obj, x, y, area, material, varargin)</a></li><li><a href="#_sub4" class="code">function plt = plot(obj, varargin)</a></li><li><a href="#_sub5" class="code">function [xi, yi] = getCentroid(obj)</a></li><li><a href="#_sub6" class="code">function area = getArea(obj)</a></li><li><a href="#_sub7" class="code">function updateProps(obj)</a></li><li><a href="#_sub8" class="code">function jac = calcJac(obj, e0, phix, phiy)</a></li><li><a href="#_sub9" class="code">function mx = calcMx(obj, e0, phix, phiy)</a></li><li><a href="#_sub10" class="code">function my = calcMy(obj, e0, phix, phiy)</a></li><li><a href="#_sub11" class="code">function p = calcP(obj, e0, phix, phiy)</a></li><li><a href="#_sub12" class="code">function [xmin, xmax, ymin, ymax] = getLimits(obj)</a></li><li><a href="#_sub13" class="code">function [x, y] = getCenter(obj)</a></li><li><a href="#_sub14" class="code">function disp(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ______________________________________________________________________</span>
0002 <span class="comment">%|                                                                      |</span>
0003 <span class="comment">%|           MCURV - Toolbox para Calculo de Momento Curvatura          |</span>
0004 <span class="comment">%|                                                                      |</span>
0005 <span class="comment">%|                    Area de Estructuras y Geotecnia                   |</span>
0006 <span class="comment">%|                   Departamento de Ingenieria Civil                   |</span>
0007 <span class="comment">%|              Facultad de Ciencias Fisicas y Matematicas              |</span>
0008 <span class="comment">%|                         Universidad de Chile                         |</span>
0009 <span class="comment">%|                                                                      |</span>
0010 <span class="comment">%| MCURV es una plataforma en MATLAB que permite realizar calculos de   |</span>
0011 <span class="comment">%| momento curvatura de secciones genericas utilizando la metodologia de|</span>
0012 <span class="comment">%| calculo no lineal Newton-Raphson.                                    |</span>
0013 <span class="comment">%|______________________________________________________________________|</span>
0014 <span class="comment">%|                                                                      |</span>
0015 <span class="comment">%| SectionDesigner                                                      |</span>
0016 <span class="comment">%|                                                                      |</span>
0017 <span class="comment">%| Clase que define la geometria y materialidad de una seccion prima-   |</span>
0018 <span class="comment">%| tica.                                                                |</span>
0019 <span class="comment">%|                                                                      |</span>
0020 <span class="comment">%| Autor: Pablo Pizarro R. @ppizarror.com                               |</span>
0021 <span class="comment">%| Licencia: MIT                                                        |</span>
0022 <span class="comment">%| Codigo fuente: https://github.com/ppizarror/MCURV                    |</span>
0023 <span class="comment">%|______________________________________________________________________|</span>
0024 
0025 classdef <a href="SectionDesigner.html" class="code" title="">SectionDesigner</a> &lt; <a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>
0026     
0027     properties(Access = private)
0028         contGeom <span class="comment">% Geometrias objetos continuos</span>
0029         contGeomPlot <span class="comment">% Guarda definicion de graficos de los objetos continuos</span>
0030         contMat <span class="comment">% Materialidad objetos continuos</span>
0031         contTotal <span class="comment">% Numero total de objetos continuos</span>
0032         contParams <span class="comment">% Parametros adicionales objetos continuos</span>
0033         singGeom <span class="comment">% Geometrias objetos singulares</span>
0034         singGeomPlot <span class="comment">% Guarda definicion de graficos de los objetos singulares</span>
0035         singMat <span class="comment">% Materialidad objetos singulares</span>
0036         singTotal <span class="comment">% Total de objetos singulares</span>
0037         singParams <span class="comment">% Parametros adicionales objetos singulares</span>
0038         x0 <span class="comment">% Guarda la posicion en x del centroide</span>
0039         y0 <span class="comment">% Guarda la posicion en y del centroide</span>
0040     <span class="keyword">end</span> <span class="comment">% protected properties</span>
0041     
0042     methods(Access = public)
0043         
0044         <a name="_sub0" href="#_subfunctions" class="code">function obj = SectionDesigner(matName)</a>
0045             <span class="comment">% SectionDesigner: Constructor de la clase</span>
0046             
0047             <span class="keyword">if</span> nargin &lt; 1
0048                 error(<span class="string">'Numero de parametros incorrectos, uso: %s'</span>, <span class="keyword">...</span>
0049                     <span class="string">'SectionDesigner(matName)'</span>);
0050             <span class="keyword">end</span>
0051             obj = obj@<a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>(matName);
0052             
0053             <span class="comment">% Genera las bases</span>
0054             obj.contGeom = {};
0055             obj.contGeomPlot = {};
0056             obj.contMat = {};
0057             obj.contTotal = 0;
0058             obj.contParams = {};
0059             obj.singParams = {};
0060             obj.singGeom = {};
0061             obj.singGeomPlot = {};
0062             obj.singMat = {};
0063             obj.singTotal = 0;
0064             
0065             <span class="comment">% Otros</span>
0066             obj.x0 = 0;
0067             obj.y0 = 0;
0068             
0069         <span class="keyword">end</span> <span class="comment">% SectionDesigner constructor</span>
0070         
0071         <a name="_sub1" href="#_subfunctions" class="code">function addDiscreteRect(obj, xc, yc, b, h, nx, ny, material, varargin)</a>
0072             <span class="comment">% addDiscreteRect: Agrega un rectangulo discreto a la seccion,</span>
0073             <span class="comment">% con centro (xc,yc) altura h, ancho b y una materialidad</span>
0074             <span class="comment">%</span>
0075             <span class="comment">% Parametros opcionales</span>
0076             <span class="comment">%   color           Color del area</span>
0077             <span class="comment">%   linewidth       Ancho de linea de la seccion</span>
0078             <span class="comment">%   transparency    Transparencia de la seccion</span>
0079 
0080             <span class="keyword">if</span> nargin &lt; 8
0081                 error(<span class="string">'Numero de parametros incorrectos, uso: %s'</span>, <span class="keyword">...</span>
0082                     <span class="string">'addDiscreteRect(obj,xc,yc,b,h,nx,ny,material,varargin)'</span>);
0083             <span class="keyword">end</span>
0084             <span class="keyword">if</span> ~isa(material, <span class="string">'GenericMaterial'</span>)
0085                 error(<span class="string">'Material no es un objeto de clase GenericMaterial'</span>);
0086             <span class="keyword">end</span>
0087             
0088             p = inputParser;
0089             p.KeepUnmatched = true;
0090             p.addOptional(<span class="string">'color'</span>, material.getColor());
0091             p.addOptional(<span class="string">'linewidth'</span>, 0.5);
0092             p.addOptional(<span class="string">'transparency'</span>, 0.6);
0093             addParameter(p, <span class="string">'MCURVgeometry'</span>, <span class="string">'rectangle'</span>);
0094             parse(p, varargin{:});
0095             r = p.Results;
0096             
0097             obj.contTotal = obj.contTotal + 1;
0098             obj.contGeomPlot{obj.contTotal} = [xc - b / 2, yc - h / 2, b, h];
0099             obj.contMat{obj.contTotal} = material;
0100             obj.contParams{obj.contTotal} = r;
0101             
0102             <span class="comment">% Genera la discretizacion</span>
0103             dx = b / nx;
0104             dy = h / ny;
0105             
0106             tn = nx * ny; <span class="comment">% Puntos totales</span>
0107             px = zeros(tn, 1); <span class="comment">% Puntos en x</span>
0108             py = zeros(tn, 1); <span class="comment">% Puntos en y</span>
0109             
0110             y = yc - h / 2 + dy / 2;
0111             k = 1; <span class="comment">% Guarda el numero del punto</span>
0112             <span class="keyword">for</span> i = 1:ny
0113                 x = xc - b / 2 + dx / 2;
0114                 <span class="keyword">for</span> j = 1:nx
0115                     px(k) = x;
0116                     py(k) = y;
0117                     x = x + dx;
0118                     k = k + 1;
0119                 <span class="keyword">end</span>
0120                 y = y + dy;
0121             <span class="keyword">end</span>
0122             
0123             <span class="comment">% Guarda la geometria</span>
0124             obj.contGeom{obj.contTotal} = {px, py, dx, dy, tn, xc, yc, b * h, b, h};
0125             
0126         <span class="keyword">end</span> <span class="comment">% addDiscreteRect function</span>
0127         
0128         <a name="_sub2" href="#_subfunctions" class="code">function addFiniteArea(obj, x, y, area, material, varargin)</a>
0129             <span class="comment">% addFiniteArea: Agrega un area finita</span>
0130             <span class="comment">%</span>
0131             <span class="comment">% Parametros opcionales</span>
0132             <span class="comment">%   color           Color del area</span>
0133             <span class="comment">%   transparency    Transparencia de la seccion</span>
0134             
0135             <span class="keyword">if</span> nargin &lt; 5
0136                 error(<span class="string">'Numero de parametros incorrectos, uso: %s'</span>, <span class="keyword">...</span>
0137                     <span class="string">'addFiniteArea(obj,x,y,area,material,varargin)'</span>);
0138             <span class="keyword">end</span>
0139             <span class="keyword">if</span> ~isa(material, <span class="string">'GenericMaterial'</span>)
0140                 error(<span class="string">'Material no es un objeto de clase GenericMaterial'</span>);
0141             <span class="keyword">end</span>
0142             
0143             p = inputParser;
0144             p.KeepUnmatched = true;
0145             p.addOptional(<span class="string">'color'</span>, material.getColor());
0146             p.addOptional(<span class="string">'transparency'</span>, 0);
0147             parse(p, varargin{:});
0148             r = p.Results;
0149             r.transparency = 1 - r.transparency;
0150             
0151             obj.singTotal = obj.singTotal + 1;
0152             b = sqrt(area);
0153             obj.singGeomPlot{obj.singTotal} = [x - b / 2, y - b / 2, b, b];
0154             obj.singMat{obj.singTotal} = material;
0155             obj.singParams{obj.singTotal} = r;
0156             obj.singGeom{obj.singTotal} = {x, y, area};
0157             
0158         <span class="keyword">end</span> <span class="comment">% addFiniteArea function</span>
0159         
0160         <a name="_sub3" href="#_subfunctions" class="code">function plt = plot(obj, varargin)</a>
0161             <span class="comment">% plot: Grafica la seccion</span>
0162             <span class="comment">%</span>
0163             <span class="comment">% Parametros opcionales:</span>
0164             <span class="comment">%   center              Muestra o no el centroide</span>
0165             <span class="comment">%   centerColor         Color del centroide</span>
0166             <span class="comment">%   centerLineWidth     Ancho de linea del centroide</span>
0167             <span class="comment">%   centerMarkerSize    Tamano del marcador</span>
0168             <span class="comment">%   centroid            Muestra o no el centroide</span>
0169             <span class="comment">%   centroidColor       Color del centroide</span>
0170             <span class="comment">%   centroidLineWidth   Ancho de linea del centroide</span>
0171             <span class="comment">%   centroidMarkerSize  Tamano del marcador</span>
0172             <span class="comment">%   limMargin           Incrementa el margen</span>
0173             <span class="comment">%   showdisc            Grafica la discretizacion</span>
0174             <span class="comment">%   title               Titulo del grafico</span>
0175             <span class="comment">%   units               Unidades del modelo</span>
0176             
0177             p = inputParser;
0178             p.KeepUnmatched = true;
0179             p.addOptional(<span class="string">'centroid'</span>, true);
0180             p.addOptional(<span class="string">'centroidColor'</span>, [1, 1, 0]);
0181             p.addOptional(<span class="string">'centroidLineWidth'</span>, 2);
0182             p.addOptional(<span class="string">'centroidMarkerSize'</span>, 10);
0183             p.addOptional(<span class="string">'center'</span>, true);
0184             p.addOptional(<span class="string">'centerColor'</span>, [0, 0, 0]);
0185             p.addOptional(<span class="string">'centerLineWidth'</span>, 0.5);
0186             p.addOptional(<span class="string">'centerMarkerSize'</span>, 10);
0187             p.addOptional(<span class="string">'limMargin'</span>, 0.1);
0188             p.addOptional(<span class="string">'showdisc'</span>, false);
0189             p.addOptional(<span class="string">'title'</span>, obj.getName());
0190             p.addOptional(<span class="string">'units'</span>, <span class="string">'mm'</span>);
0191             parse(p, varargin{:});
0192             r = p.Results;
0193             
0194             <span class="comment">% Genera la figura</span>
0195             plt = figure();
0196             movegui(plt, <span class="string">'center'</span>);
0197             set(gcf, <span class="string">'name'</span>, r.title);
0198             hold on;
0199             grid on;
0200             grid minor;
0201             axis equal;
0202             
0203             <span class="comment">% Agrega los elementos continuos</span>
0204             <span class="keyword">for</span> i = 1:obj.contTotal
0205                 <span class="keyword">if</span> strcmp(obj.contParams{i}.MCURVgeometry, <span class="string">'rectangle'</span>)
0206                     rectangle(<span class="string">'Position'</span>, obj.contGeomPlot{i}, <span class="keyword">...</span>
0207                         <span class="string">'FaceColor'</span>, [obj.contParams{i}.color, obj.contParams{i}.transparency], <span class="keyword">...</span>
0208                         <span class="string">'EdgeColor'</span>, obj.contParams{i}.color, <span class="keyword">...</span>
0209                         <span class="string">'LineWidth'</span>, obj.contParams{i}.linewidth);
0210                 <span class="keyword">end</span>
0211             <span class="keyword">end</span>
0212             
0213             <span class="comment">% Grafica la discretizacion de los elementos continuos</span>
0214             <span class="keyword">if</span> r.showdisc
0215                 <span class="keyword">for</span> i = 1:obj.contTotal
0216                     g = obj.contGeom{i};
0217                     px = g{1};
0218                     py = g{2};
0219                     dx = g{3};
0220                     dy = g{4};
0221                     tn = g{5};
0222                     
0223                     <span class="keyword">for</span> j = 1:tn
0224                         rectangle(<span class="string">'Position'</span>, [px(j) - dx / 2, py(j) - dy / 2, dx, dy], <span class="keyword">...</span>
0225                             <span class="string">'EdgeColor'</span>, [obj.contParams{i}.color, 0.25], <span class="keyword">...</span>
0226                             <span class="string">'LineWidth'</span>, obj.contParams{i}.linewidth*0.5);
0227                         <a href="#_sub4" class="code" title="subfunction plt = plot(obj, varargin)">plot</a>(px(j), py(j), <span class="string">'.'</span>, <span class="string">'MarkerSize'</span>, 10, <span class="string">'Color'</span>, <span class="keyword">...</span>
0228                             [obj.contParams{i}.color, 0.25]);
0229                     <span class="keyword">end</span>
0230                     
0231                 <span class="keyword">end</span>
0232             <span class="keyword">end</span>
0233             
0234             <span class="comment">% Agrega los elementos discretos</span>
0235             <span class="keyword">for</span> i = 1:obj.singTotal
0236                 rectangle(<span class="string">'Position'</span>, obj.singGeomPlot{i}, <span class="keyword">...</span>
0237                     <span class="string">'FaceColor'</span>, [obj.singParams{i}.color, obj.singParams{i}.transparency], <span class="keyword">...</span>
0238                     <span class="string">'EdgeColor'</span>, [obj.singParams{i}.color, obj.singParams{i}.transparency]);
0239             <span class="keyword">end</span>
0240             
0241             <span class="comment">% Modifica los ejes para dejar la misma escala</span>
0242             xlim(get(gca, <span class="string">'xlim'</span>).*(1 + r.limMargin));
0243             ylim(get(gca, <span class="string">'ylim'</span>).*(1 + r.limMargin));
0244             
0245             <span class="comment">% Cambia los label</span>
0246             xlabel(sprintf(<span class="string">'x (%s)'</span>, r.units));
0247             ylabel(sprintf(<span class="string">'y (%s)'</span>, r.units));
0248             title(r.title);
0249             
0250             <span class="comment">% Escribe el centro de gravedad</span>
0251             <span class="keyword">if</span> r.centroid
0252                 [x, y] = obj.getCentroid();
0253                 <a href="#_sub4" class="code" title="subfunction plt = plot(obj, varargin)">plot</a>(x, y, <span class="string">'+'</span>, <span class="string">'Color'</span>, r.centroidColor, <span class="string">'MarkerSize'</span>, <span class="keyword">...</span>
0254                     r.centroidMarkerSize, <span class="string">'LineWidth'</span>, r.centroidLineWidth);
0255             <span class="keyword">end</span>
0256             
0257             <span class="comment">% Escribe el centro geometrico</span>
0258             <span class="keyword">if</span> r.center
0259                 [gx, gy] = obj.getCenter();
0260                 <a href="#_sub4" class="code" title="subfunction plt = plot(obj, varargin)">plot</a>(gx, gy, <span class="string">'+'</span>, <span class="string">'Color'</span>, r.centerColor, <span class="string">'MarkerSize'</span>, <span class="keyword">...</span>
0261                     r.centerMarkerSize, <span class="string">'LineWidth'</span>, r.centerLineWidth);
0262             <span class="keyword">end</span>
0263             
0264             <span class="comment">% Finaliza el grafico</span>
0265             drawnow();
0266             
0267         <span class="keyword">end</span> <span class="comment">% plot function</span>
0268         
0269         <a name="_sub4" href="#_subfunctions" class="code">function [xi, yi] = getCentroid(obj)</a>
0270             <span class="comment">% getCentroid: Calcula el centroide</span>
0271             
0272             <span class="comment">% Calcula el centroide en x</span>
0273             xid = 0;
0274             yid = 0;
0275             at = 0; <span class="comment">% Area total</span>
0276             <span class="keyword">for</span> i = 1:obj.contTotal
0277                 g = obj.contGeom{i};
0278                 xid = xid + g{6} * g{8};
0279                 yid = yid + g{7} * g{8};
0280                 at = at + g{8};
0281             <span class="keyword">end</span>
0282             
0283             <span class="keyword">for</span> i = 1:obj.singTotal
0284                 g = obj.singGeom{i};
0285                 xid = xid + g{1} * g{3};
0286                 yid = yid + g{2} * g{3};
0287                 at = at + g{3};
0288             <span class="keyword">end</span>
0289             
0290             <span class="comment">% Calcula el centride</span>
0291             xi = xid / at;
0292             yi = yid / at;
0293             
0294         <span class="keyword">end</span> <span class="comment">% getCentroid function</span>
0295         
0296         <a name="_sub5" href="#_subfunctions" class="code">function area = getArea(obj)</a>
0297             <span class="comment">% getArea: Calcula el area total</span>
0298             
0299             area = 0; <span class="comment">% Area total</span>
0300             <span class="keyword">for</span> i = 1:obj.contTotal
0301                 g = obj.contGeom{i};
0302                 area = area + g{8};
0303             <span class="keyword">end</span>
0304             <span class="keyword">for</span> i = 1:obj.singTotal
0305                 g = obj.singGeom{i};
0306                 area = area + g{3};
0307             <span class="keyword">end</span>
0308             
0309         <span class="keyword">end</span> <span class="comment">% getArea function</span>
0310         
0311         <a name="_sub6" href="#_subfunctions" class="code">function updateProps(obj)</a>
0312             <span class="comment">% updateProps: Actualiza las propiedades del modelo previo</span>
0313             <span class="comment">% analisis</span>
0314             
0315             [x, y] = obj.getCentroid();
0316             obj.x0 = x;
0317             obj.y0 = y;
0318             
0319         <span class="keyword">end</span> <span class="comment">% updateProps function</span>
0320         
0321         <a name="_sub7" href="#_subfunctions" class="code">function jac = calcJac(obj, e0, phix, phiy)</a>
0322             <span class="comment">% calcJac: Calcula el jacobiano de la seccion</span>
0323             
0324             <span class="comment">% Crea funcion deformacion</span>
0325             eps = @(x, y) e0 + phix * (y - obj.y0) - phiy * (x - obj.x0);
0326             
0327             <span class="comment">% Valores del jacobiano</span>
0328             aP_ae0 = 0;
0329             aP_aphix = 0;
0330             aP_aphiy = 0;
0331             aMx_aphix = 0;
0332             aMx_aphiy = 0;
0333             aMy_aphiy = 0;
0334             
0335             <span class="comment">% Calcula las integrales</span>
0336             <span class="keyword">for</span> j = 1:obj.contTotal
0337                 
0338                 g = obj.contGeom{j};
0339                 px = g{1};
0340                 py = g{2};
0341                 mat = obj.contMat{j};
0342                 dd = g{3} * g{4};
0343                 nt = g{5};
0344                 <span class="keyword">for</span> i = 1:nt <span class="comment">% Avanza en los puntos continuos</span>
0345                     
0346                     <span class="comment">% Calcula la deformacion</span>
0347                     e_i = eps(px(i), py(i));
0348                     
0349                     <span class="comment">% Calcula la rigidez tangente</span>
0350                     [~, Ec] = mat.eval(e_i);
0351                     
0352                     <span class="comment">% Calcula los jacobianos</span>
0353                     aP_ae0 = aP_ae0 + Ec * dd; <span class="comment">% aP/ae0</span>
0354                     aP_aphix = aP_aphix + Ec * (py(i) - obj.y0) * dd; <span class="comment">% aP/aphix</span>
0355                     aP_aphiy = aP_aphiy - Ec * (px(i) - obj.x0) * dd; <span class="comment">% aP/aphiy</span>
0356                     aMx_aphix = aMx_aphix + Ec * ((py(i) - obj.y0)^2) * dd; <span class="comment">% aMx/aphix</span>
0357                     aMx_aphiy = aMx_aphiy - Ec * (py(i) - obj.y0) * (px(i) - obj.x0) * dd; <span class="comment">% aMx/aphiy</span>
0358                     aMy_aphiy = aMy_aphiy + Ec * ((px(i) - obj.x0)^2) * dd; <span class="comment">% aMy/aphiy</span>
0359                     
0360                 <span class="keyword">end</span>
0361             <span class="keyword">end</span>
0362             
0363             <span class="comment">% Agrega objetos puntuales</span>
0364             <span class="keyword">for</span> j = 1:obj.singTotal
0365                 
0366                 g = obj.singGeom{j};
0367                 px = g{1};
0368                 py = g{2};
0369                 mat = obj.singMat{j};
0370                 area = g{3};
0371                 
0372                 <span class="comment">% Calcula la deformacion</span>
0373                 e_i = eps(px, py);
0374                 
0375                 <span class="comment">% Calcula la rigidez tangente del suelo</span>
0376                 [~, Ec] = mat.eval(e_i);
0377                 
0378                 <span class="comment">% Calcula los jacobianos</span>
0379                 aP_ae0 = aP_ae0 + Ec * area; <span class="comment">% aP/ae0</span>
0380                 aP_aphix = aP_aphix + Ec * (py - obj.y0) * area; <span class="comment">% aP/aphix</span>
0381                 aP_aphiy = aP_aphiy - Ec * (px - obj.x0) * area; <span class="comment">% aP/aphiy</span>
0382                 aMx_aphix = aMx_aphix + Ec * ((py - obj.y0)^2) * area; <span class="comment">% aMx/aphix</span>
0383                 aMx_aphiy = aMx_aphiy - Ec * (py - obj.y0) * (px - obj.x0) * area; <span class="comment">% aMx/aphiy</span>
0384                 aMy_aphiy = aMy_aphiy + Ec * ((px - obj.x0)^2) * area; <span class="comment">% aMy/aphiy</span>
0385             <span class="keyword">end</span>
0386             
0387             <span class="comment">% Asigna los valores iguales</span>
0388             aMx_ae0 = aP_aphix;
0389             aMy_ae0 = aP_aphiy;
0390             aMy_aphix = aMx_aphiy;
0391             
0392             <span class="comment">% Genera el jacobiano</span>
0393             jac = [[aP_ae0, aP_aphix, aP_aphiy]; <span class="keyword">...</span>
0394                 [aMx_ae0, aMx_aphix, aMx_aphiy]; <span class="keyword">...</span>
0395                 [aMy_ae0, aMy_aphix, aMy_aphiy]];
0396             
0397         <span class="keyword">end</span> <span class="comment">% calcJac function</span>
0398         
0399         <a name="_sub8" href="#_subfunctions" class="code">function mx = calcMx(obj, e0, phix, phiy)</a>
0400             <span class="comment">% calcMx: Calcula el momento con respecto al eje x</span>
0401             
0402             <span class="comment">% Crea funcion deformacion</span>
0403             eps = @(x, y) e0 + phix * (y - obj.y0) - phiy * (x - obj.x0);
0404             
0405             <span class="comment">% Calcula la integral para objetos continuos</span>
0406             mx = 0;
0407             <span class="keyword">for</span> j = 1:obj.contTotal
0408                 g = obj.contGeom{j};
0409                 px = g{1};
0410                 py = g{2};
0411                 mat = obj.contMat{j};
0412                 dd = g{3} * g{4};
0413                 nt = g{5};
0414                 
0415                 <span class="keyword">for</span> i = 1:nt <span class="comment">% Avanza en los puntos continuos</span>
0416                     <span class="comment">% Calcula la deformacion</span>
0417                     e_i = eps(px(i), py(i));
0418                     
0419                     <span class="comment">% Calcula la tension</span>
0420                     [fc, ~] = mat.eval(e_i);
0421                     
0422                     <span class="comment">% Calcula el momento</span>
0423                     mx = mx + fc * (py(i) - obj.y0) * dd;
0424                 <span class="keyword">end</span>
0425             <span class="keyword">end</span>
0426             
0427             <span class="comment">% Agrega los objetos singulares</span>
0428             <span class="keyword">for</span> j = 1:obj.singTotal
0429                 g = obj.singGeom{j};
0430                 px = g{1};
0431                 py = g{2};
0432                 mat = obj.singMat{j};
0433                 area = g{3};
0434                 
0435                 <span class="comment">% Calcula la deformacion</span>
0436                 e_i = eps(px, py);
0437                 
0438                 <span class="comment">% Calcula la tension</span>
0439                 [fc, ~] = mat.eval(e_i);
0440                 
0441                 <span class="comment">% Suma el momento</span>
0442                 mx = mx + fc * (py - obj.y0) * area;
0443             <span class="keyword">end</span>
0444             
0445         <span class="keyword">end</span> <span class="comment">% calcMx function</span>
0446         
0447         <a name="_sub9" href="#_subfunctions" class="code">function my = calcMy(obj, e0, phix, phiy)</a>
0448             <span class="comment">% calcMy: Calcula el momento con respecto al eje y</span>
0449             
0450             <span class="comment">% Crea funcion deformacion</span>
0451             eps = @(x, y) e0 + phix * (y - obj.y0) - phiy * (x - obj.x0);
0452             
0453             <span class="comment">% Calcula la integral para objetos continuos</span>
0454             my = 0;
0455             <span class="keyword">for</span> j = 1:obj.contTotal
0456                 g = obj.contGeom{j};
0457                 px = g{1};
0458                 py = g{2};
0459                 mat = obj.contMat{j};
0460                 dd = g{3} * g{4};
0461                 nt = g{5};
0462                 
0463                 <span class="keyword">for</span> i = 1:nt <span class="comment">% Avanza en los puntos continuos</span>
0464                     <span class="comment">% Calcula la deformacion</span>
0465                     e_i = eps(px(i), py(i));
0466                     
0467                     <span class="comment">% Calcula la tension</span>
0468                     [fc, ~] = mat.eval(e_i);
0469                     
0470                     <span class="comment">% Calcula el momento</span>
0471                     my = my - fc * (px(i) - obj.x0) * dd;
0472                 <span class="keyword">end</span>
0473             <span class="keyword">end</span>
0474             
0475             <span class="comment">% Agrega los objetos singulares</span>
0476             <span class="keyword">for</span> j = 1:obj.singTotal
0477                 g = obj.singGeom{j};
0478                 px = g{1};
0479                 py = g{2};
0480                 mat = obj.singMat{j};
0481                 area = g{3};
0482                 
0483                 <span class="comment">% Calcula la deformacion</span>
0484                 e_i = eps(px, py);
0485                 
0486                 <span class="comment">% Calcula la tension</span>
0487                 [fc, ~] = mat.eval(e_i);
0488                 
0489                 <span class="comment">% Suma el momento</span>
0490                 my = my - fc * (px - obj.x0) * area;
0491             <span class="keyword">end</span>
0492             
0493         <span class="keyword">end</span> <span class="comment">% calcMy function</span>
0494         
0495         <a name="_sub10" href="#_subfunctions" class="code">function p = calcP(obj, e0, phix, phiy)</a>
0496             <span class="comment">% calcP: Calcula la carga axial</span>
0497             
0498             <span class="comment">% Crea funcion deformacion</span>
0499             eps = @(x, y) e0 + phix * (y - obj.y0) - phiy * (x - obj.x0);
0500             
0501             <span class="comment">% Calcula la integral para objetos continuos</span>
0502             p = 0;
0503             <span class="keyword">for</span> j = 1:obj.contTotal
0504                 g = obj.contGeom{j};
0505                 px = g{1};
0506                 py = g{2};
0507                 mat = obj.contMat{j};
0508                 dd = g{3} * g{4};
0509                 nt = g{5};
0510                 
0511                 <span class="keyword">for</span> i = 1:nt <span class="comment">% Avanza en los puntos continuos</span>
0512                     <span class="comment">% Calcula la deformacion</span>
0513                     e_i = eps(px(i), py(i));
0514                     
0515                     <span class="comment">% Calcula la tension</span>
0516                     [fc, ~] = mat.eval(e_i);
0517                     
0518                     <span class="comment">% Calcula el momento</span>
0519                     p = p + fc * dd;
0520                 <span class="keyword">end</span>
0521             <span class="keyword">end</span>
0522             
0523             <span class="comment">% Agrega los objetos singulares</span>
0524             <span class="keyword">for</span> j = 1:obj.singTotal
0525                 g = obj.singGeom{j};
0526                 px = g{1};
0527                 py = g{2};
0528                 mat = obj.singMat{j};
0529                 area = g{3};
0530                 
0531                 <span class="comment">% Calcula la deformacion</span>
0532                 e_i = eps(px, py);
0533                 
0534                 <span class="comment">% Calcula la tension</span>
0535                 [fc, ~] = mat.eval(e_i);
0536                 
0537                 <span class="comment">% Suma el momento</span>
0538                 p = p + fc * area;
0539             <span class="keyword">end</span>
0540             
0541         <span class="keyword">end</span> <span class="comment">% calcP function</span>
0542         
0543         <a name="_sub11" href="#_subfunctions" class="code">function [xmin, xmax, ymin, ymax] = getLimits(obj)</a>
0544             <span class="comment">% getLimits: Calcula los limites de la seccion</span>
0545             
0546             xmin = Inf;
0547             xmax = -Inf;
0548             ymin = Inf;
0549             ymax = -Inf;
0550             
0551             <span class="comment">% Recorre los objetos continuos</span>
0552             <span class="keyword">for</span> j = 1:obj.contTotal
0553                 g = obj.contGeom{j};
0554                 xc = g{6};
0555                 yc = g{7};
0556                 b = g{9};
0557                 h = g{10};
0558                 xmin = min(xmin, xc-b/2);
0559                 xmax = max(xmax, xc+b/2);
0560                 ymin = min(ymin, yc-h/2);
0561                 ymax = max(ymax, yc+h/2);
0562             <span class="keyword">end</span>
0563             
0564             <span class="comment">% Agrega objetos puntuales</span>
0565             <span class="keyword">for</span> j = 1:obj.singTotal
0566                 g = obj.singGeom{j};
0567                 pjx = g{1};
0568                 pjy = g{2};
0569                 xmin = min(xmin, pjx);
0570                 xmax = max(xmax, pjx);
0571                 ymin = min(ymin, pjy);
0572                 ymax = max(ymax, pjy);
0573             <span class="keyword">end</span>
0574             
0575         <span class="keyword">end</span> <span class="comment">% getLimits function</span>
0576         
0577         <a name="_sub12" href="#_subfunctions" class="code">function [x, y] = getCenter(obj)</a>
0578             <span class="comment">% calcGeometricCenter: Calcula el centro del limite</span>
0579             
0580             [xmin, xmax, ymin, ymax] = obj.getLimits();
0581             x = (xmax+xmin)/2;
0582             y = (ymax+ymin)/2;
0583             
0584         <span class="keyword">end</span> <span class="comment">% calcGeometricCenter function</span>
0585         
0586         <a name="_sub13" href="#_subfunctions" class="code">function disp(obj)</a>
0587             <span class="comment">% disp: Imprime la informacion del objeto en consola</span>
0588             
0589             fprintf(<span class="string">'Section designer:\n'</span>);
0590             <a href="#_sub14" class="code" title="subfunction disp(obj)">disp</a>@<a href="../../mcurv/base/BaseModel.html" class="code" title="">BaseModel</a>(obj);
0591             
0592             [cx, cy] = obj.getCentroid();
0593             [gx, gy] = obj.getCenter();
0594             [xmin, xmax, ymin, ymax] = obj.getLimits();
0595             
0596             fprintf(<span class="string">'\tCentroide: %.2f, %.2f\n'</span>, cx, cy);
0597             fprintf(<span class="string">'\tCentro geometrico: %.2f, %.2f\n'</span>, gx, gy);
0598             fprintf(<span class="string">'\tArea: %.2f\n'</span>, obj.getArea());
0599             fprintf(<span class="string">'\tAncho: %.2f\n'</span>, abs(xmax-xmin));
0600             fprintf(<span class="string">'\tAlto: %.2f\n'</span>, abs(ymax-ymin));
0601             fprintf(<span class="string">'\tNumero de elementos: %d\n\t\tContinuos: %d\n\t\tFinitos: %d\n'</span>, <span class="keyword">...</span>
0602                 obj.contTotal+obj.singTotal, obj.contTotal, obj.singTotal);
0603             fprintf(<span class="string">'\tLimites de la seccion:\n\t\tx: (%.2f, %.2f)\n\t\ty: (%.2f, %.2f)\n'</span>, <span class="keyword">...</span>
0604                 xmin, xmax, ymin, ymax);
0605             
0606             <a href="../../mcurv/utils/dispMCURV.html" class="code" title="function dispMCURV()">dispMCURV</a>();
0607             
0608         <span class="keyword">end</span> <span class="comment">% disp function</span>
0609         
0610     <span class="keyword">end</span> <span class="comment">% public methods</span>
0611     
0612 <span class="keyword">end</span> <span class="comment">% SectionDesigner class</span></pre></div>
<hr><address>Generated on Thu 16-May-2019 02:09:19 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>